// ################################################################################
// FILE       : SPELLcallstack.H
// DATE       : Mar 17, 2011
// PROJECT    : SPELL
// DESCRIPTION: Call stack model.
// --------------------------------------------------------------------------------
//
//  Copyright (C) 2008, 2015 SES ENGINEERING, Luxembourg S.A.R.L.
//
//  This file is part of SPELL.
//
// SPELL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// SPELL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with SPELL. If not, see <http://www.gnu.org/licenses/>.
//
// ################################################################################

#ifndef __SPELL_CALLSTACK_H__
#define __SPELL_CALLSTACK_H__

// FILES TO INCLUDE ////////////////////////////////////////////////////////
// System includes ---------------------------------------------------------
// Local includes ----------------------------------------------------------
#include "SPELL_EXC/SPELLcallstackIF.H"
#include "SPELL_EXC/SPELLcodeTreeNodeIF.H"
// Project includes --------------------------------------------------------
#include "SPELL_SYN/SPELLmutex.H"

/** \addtogroup SPELL_EXC */
/*@{*/


// FORWARD REFERENCES //////////////////////////////////////////////////////
// TYPES ///////////////////////////////////////////////////////////////////
// DEFINES /////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/**
 ** \brief Call stack model
 **
 ** \par Description and usage:
 **
 ** 	The stack model keeps track of the position of the
 **  	execution within the chain of procedure and sub-procedures, local or
 **  	external functions, etc. The callstack provides the ability to step
 **  	over functions (execution marker remains on a function call instead
 **  	of going inside it).
 **
 ** 	It is instantiated by the SPELLinterpreter, it is used by the
 **  	SPELLexecutor to process the dispatch events and extract stack
 **  	information from them.
 **
**////////////////////////////////////////////////////////////////////////////
class SPELLcallstack : public SPELLcallstackIF
{
public: //--------------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Constructor.
		**////////////////////////////////////////////////////////////////////
		SPELLcallstack();

		//////////////////////////////////////////////////////////////////////
		/** Destructor.
		**////////////////////////////////////////////////////////////////////
		virtual ~SPELLcallstack();

    // STATIC ////////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcallstackIF.
		**////////////////////////////////////////////////////////////////////
		void reset();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcallstackIF.
		**////////////////////////////////////////////////////////////////////
		const std::string& getStack();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcallstackIF.
		**////////////////////////////////////////////////////////////////////
		const std::string getFullStack();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcallstackIF.
		**////////////////////////////////////////////////////////////////////
		unsigned int getCurrentLine() { return m_currentLine; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcallstackIF.
		**////////////////////////////////////////////////////////////////////
		const std::string& getCodeName();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcallstackIF.
		**////////////////////////////////////////////////////////////////////
		void stepOver( const SPELLstepOverMode& mode )
		{
			m_previousSoMode = m_soMode;
		    m_soMode = mode;
		};

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcallstackIF.
		**////////////////////////////////////////////////////////////////////
		void setRecoveryMode()
		{
			m_recoveryMode = true;
		}

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcallstackIF.
		**////////////////////////////////////////////////////////////////////
		void setStage( const std::string& id, const std::string& title );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcallstackIF.
		**////////////////////////////////////////////////////////////////////
		const std::string getStage();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcallstackIF.
		**////////////////////////////////////////////////////////////////////
		const void skipCurrentLine() { m_markExecuted = false; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcallstackIF.
		**////////////////////////////////////////////////////////////////////
		const bool isSteppingOver();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcallstackIF.
		**////////////////////////////////////////////////////////////////////
		void moveToLevel( unsigned int level );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLdispatchListener.
		**////////////////////////////////////////////////////////////////////
		std::string getId() { return "(callstack)"; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLdispatchListener.
		**////////////////////////////////////////////////////////////////////
		void callbackEventLine( PyFrameObject* frame, const std::string& file, const int line, const std::string& name);

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLdispatchListener.
		**////////////////////////////////////////////////////////////////////
		void callbackEventCall( PyFrameObject* frame, const std::string& file, const int line, const std::string& name);

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLdispatchListener.
		**////////////////////////////////////////////////////////////////////
		void callbackEventReturn( PyFrameObject* frame, const std::string& file, const int line, const std::string& name);

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLdispatchListener.
		**////////////////////////////////////////////////////////////////////
		void callbackEventError( PyFrameObject* frame, const std::string& file, const int line, const std::string& name);

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcallstackIF.
		**////////////////////////////////////////////////////////////////////
	    void enableNotifications( bool enable ) { m_notify = enable; };

    // DATA MEMBERS //////////////////////////////////////////////////////////

protected: //-----------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////
    // DATA MEMBERS //////////////////////////////////////////////////////////

private: //-------------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Recalculate full stack
		**////////////////////////////////////////////////////////////////////
		void rebuildFullStack();

		//////////////////////////////////////////////////////////////////////
		/** Clear all the stack information.
		**////////////////////////////////////////////////////////////////////
		void clearStack();

    // DATA MEMBERS //////////////////////////////////////////////////////////

		/** Holds the stack model root */
		SPELLcodeTreeNodeIF*   m_rootNode;
		/** Holds the current code (the leaf) */
		SPELLcodeTreeNodeIF*   m_currentNode;
		/** Holds the view code (the view position) */
		SPELLcodeTreeNodeIF*   m_viewNode;
		/** Executed line flag, used to know when a line is to be marked as executed
		 * or not, depending on having a skip/goto event or not*/
		bool                   m_markExecuted;
		/** True if notifications should be sent */
		bool				   m_notify;
		/** True if in error state */
		bool                   m_errorState;
		/** True if doing error recovery */
		bool                   m_recoveryMode;
		/** Step over mode */
		SPELLstepOverMode      m_soMode;
		/** Previous step over mode, required for transient modes */
		SPELLstepOverMode      m_previousSoMode;
		/** Current stage identifier if any */
		std::string            m_stageId;
		/** Current stage title if any */
		std::string            m_stageTitle;
		/** Holds the current stack string */
		std::string            m_stack;
		/** Holds the full stack */
		std::vector<std::string> m_fullStack;
		/** Holds the full stack string */
		std::string            m_fullStackString;
		/** Holds the current line number */
		unsigned int           m_currentLine;
		/** Holds the current code name string */
		std::string            m_codeName;
		/** Synchronization mutex */
		SPELLmutex             m_lock;
};

/*@}*/
#endif
