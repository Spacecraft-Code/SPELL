// ################################################################################
// FILE       : SPELLscheduler.H
// DATE       : Mar 17, 2011
// PROJECT    : SPELL
// DESCRIPTION: Implementation of the executor scheduler.
// --------------------------------------------------------------------------------
//
//  Copyright (C) 2008, 2015 SES ENGINEERING, Luxembourg S.A.R.L.
//
//  This file is part of SPELL.
//
// SPELL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// SPELL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with SPELL. If not, see <http://www.gnu.org/licenses/>.
//
// ################################################################################

#ifndef __SPELL_SCHEDULER_H__
#define __SPELL_SCHEDULER_H__

// FILES TO INCLUDE ////////////////////////////////////////////////////////
// System includes ---------------------------------------------------------
// Local includes ----------------------------------------------------------
#include "SPELL_EXC/SPELLschedulerIF.H"
#include "SPELL_EXC/SPELLexecutorStatus.H"
// Project includes --------------------------------------------------------
#include "SPELL_CIF/SPELLnotifications.H"
#include "SPELL_SYN/SPELLtimer.H"


/** \addtogroup SPELL_EXC */
/*@{*/


// FORWARD REFERENCES //////////////////////////////////////////////////////
class SPELLchecker;
// TYPES ///////////////////////////////////////////////////////////////////
// DEFINES /////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
/**
 ** \brief Execution scheduler
 **
**////////////////////////////////////////////////////////////////////////////
class SPELLscheduler : public SPELLtimerListener, public SPELLschedulerIF
{
public: //--------------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Constructor.
		 *
		 * \param useSafeCalls IN: if True, use the safe-python-ops lock to
		 * ensure correct manipulation during adapter calls. This cannot be
		 * used in the regular executor since the lock is already set by
		 * the dispatching mechanism. It is meant to be used by the shell.
		**////////////////////////////////////////////////////////////////////
		SPELLscheduler( bool useSafeCalls );

		//////////////////////////////////////////////////////////////////////
		/** Destructor.
		**////////////////////////////////////////////////////////////////////
		~SPELLscheduler();

    // STATIC ////////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Starts a time condition check.
		**////////////////////////////////////////////////////////////////////
		void startWait( const SPELLscheduleCondition& condition );

		//////////////////////////////////////////////////////////////////////
		/** Starts a prompt status
		**////////////////////////////////////////////////////////////////////
		void startPrompt( const SPELLtime& timeout, bool headless );

		//////////////////////////////////////////////////////////////////////
		/** Aborts a condition check timer if it was interrupted previously.
		 * This is called each time STEP or RUN commands are issued in a line
		 * after wait condition was paused previously.
		**////////////////////////////////////////////////////////////////////
		bool abortWait( bool setStatus );

		//////////////////////////////////////////////////////////////////////
		/** Restarts a condition check timer if it was interrupted previously.
		 * This is called each time STEP or RUN commands are issued in a line
		 * after wait condition was paused previously.
		**////////////////////////////////////////////////////////////////////
		void restartWait();

		//////////////////////////////////////////////////////////////////////
		/** Cancels a condition checking timer. This is executed each time
		 * there is a timer ongoing and the PAUSE command is received
		 * (see controller::pause method). It can be restarted afterwards
		 * with STEP command.
		**////////////////////////////////////////////////////////////////////
		bool interruptWait();

		//////////////////////////////////////////////////////////////////////
		/** Finish a wait condition
		**////////////////////////////////////////////////////////////////////
		void finishWait( bool setStatus, bool keepLock );

		//////////////////////////////////////////////////////////////////////
		/** Finish a prompt status
		**////////////////////////////////////////////////////////////////////
		void finishPrompt();

		//////////////////////////////////////////////////////////////////////
		/** Cancel a prompt status
		**////////////////////////////////////////////////////////////////////
		void cancelPrompt();

		//////////////////////////////////////////////////////////////////////
		/** Wait the scheduling event
		**////////////////////////////////////////////////////////////////////
		void wait();

		//////////////////////////////////////////////////////////////////////
		/** Get the schedule result
		**////////////////////////////////////////////////////////////////////
		const SPELLscheduleResult& result() const {
			return m_result;
		};

		//////////////////////////////////////////////////////////////////////
		/** Check if there is a checking algorithm (Checker) running
		**////////////////////////////////////////////////////////////////////
		bool waiting();

		//////////////////////////////////////////////////////////////////////
		/** Check if there is a prompt waiting
		**////////////////////////////////////////////////////////////////////
		bool inPrompt();

		//////////////////////////////////////////////////////////////////////
		/** Wait a given condition to be fullfilled
		**////////////////////////////////////////////////////////////////////
		bool waitCondition( std::string condition );

		//////////////////////////////////////////////////////////////////////
		/** Timer callback, see Timer class documentation
		**////////////////////////////////////////////////////////////////////
		bool timerCallback( unsigned long elapsed );

		//////////////////////////////////////////////////////////////////////
		/** Set the default prompt warning delay
		**////////////////////////////////////////////////////////////////////
		void setPromptWarningDelay( unsigned int secs );

    // DATA MEMBERS //////////////////////////////////////////////////////////

protected: //-----------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////
    // DATA MEMBERS //////////////////////////////////////////////////////////
		/** Holds the scheduling condition details */
		SPELLscheduleCondition		   m_condition;
		/** Holds the result of the last condition */
		SPELLscheduleResult            m_result;
		/** Block procedure execution while a condition checking is being run */
		SPELLevent                     m_waitingEvent;

private: //-------------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Release the lock which may be blocking procedure execution
		**////////////////////////////////////////////////////////////////////
		void releaseLanguageLock();

		//////////////////////////////////////////////////////////////////////
		/** Set the lock to block procedure execution
		**////////////////////////////////////////////////////////////////////
		void setLanguageLock( const SPELLexecutorStatus& st );

		//////////////////////////////////////////////////////////////////////
		/** Reset controller status to the appropriate one
		**////////////////////////////////////////////////////////////////////
		void resetControllerStatus( bool keepLock );

		//////////////////////////////////////////////////////////////////////
		/** Check time conditions
		**////////////////////////////////////////////////////////////////////
		bool checkTime();

		//////////////////////////////////////////////////////////////////////
		/** Check expression
		**////////////////////////////////////////////////////////////////////
		bool checkExpression();

		//////////////////////////////////////////////////////////////////////
		/** Check child procedure
		**////////////////////////////////////////////////////////////////////
		bool checkChildProcedure();

		//////////////////////////////////////////////////////////////////////
		/** Check TM verification
		**////////////////////////////////////////////////////////////////////
		bool checkVerification();

		//////////////////////////////////////////////////////////////////////
		/** Time notification
		**////////////////////////////////////////////////////////////////////
		void notifyTime( bool finished, bool success );

		//////////////////////////////////////////////////////////////////////
		/** Inject a warning event message
		**////////////////////////////////////////////////////////////////////
		void raiseEvent( const std::string& message );

		//////////////////////////////////////////////////////////////////////
		/** Prepare and start a timer for checks
		**////////////////////////////////////////////////////////////////////
		void startTimer();

		//////////////////////////////////////////////////////////////////////
		/** Send notification data
		**////////////////////////////////////////////////////////////////////
		void notify( const ItemNotification& item );

		//////////////////////////////////////////////////////////////////////
		/** Send message data
		**////////////////////////////////////////////////////////////////////
		void message( const std::string& message );

    // DATA MEMBERS //////////////////////////////////////////////////////////
		/** Timer for checks */
		SPELLtimer*                    m_timer;
		/** Holds the start time of the check */
		SPELLtime					   m_checkStartTime;
		/** Holds the target time of the check if any */
		SPELLtime					   m_checkTargetTime;
		/** Holds the latest notification time*/
		SPELLtime                      m_lastNotificationTime;
		/** Holds the current notification period */
		SPELLtime                      m_notificationPeriod;
		/** Holds the default prompt warning delay in seconds */
		unsigned int                   m_defaultPromptWarningDelay;
		/** Holds the current notification period index */
		unsigned int                   m_notificationPeriodIndex;
		/** True if check is silent */
		bool                           m_silentCheck;
		/** Borrowed reference of the TM interface */
		PyObject*					   m_pyTM;
		/** Synchronization lock */
		SPELLmutex                     m_lock;
		/** Synchronization lock for thread checks */
		SPELLmutex                     m_checkLock;
		/** Timer abort flag */
		bool                           m_abortTimer;
		/** Last notified item */
		ItemNotification               m_lastNotifiedItem;
		/** Use safe calls */
		bool                           m_useSafeCalls;

};

/*@}*/
#endif
