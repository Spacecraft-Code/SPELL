// ################################################################################
// FILE       : SPELLexecutorImpl.H
// DATE       : Mar 17, 2011
// PROJECT    : SPELL
// DESCRIPTION: Implementation of the Executor.
// --------------------------------------------------------------------------------
//
//  Copyright (C) 2008, 2015 SES ENGINEERING, Luxembourg S.A.R.L.
//
//  This file is part of SPELL.
//
// SPELL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// SPELL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with SPELL. If not, see <http://www.gnu.org/licenses/>.
//
// ################################################################################

#ifndef __SPELL_EXECUTOR_IMPL_H__
#define __SPELL_EXECUTOR_IMPL_H__

// FILES TO INCLUDE ////////////////////////////////////////////////////////
// Local includes ----------------------------------------------------------
#include "SPELL_EXC/SPELLexecutorIF.H"
#include "SPELL_EXC/SPELLimportChecker.H"
#include "SPELL_EXC/SPELLbreakpointType.H"
// Project includes --------------------------------------------------------
#include "SPELL_CFG/SPELLbrowsableLibMode.H"
// System includes ---------------------------------------------------------


/** \addtogroup SPELL_EXC */
/*@{*/


// FORWARD REFERENCES //////////////////////////////////////////////////////
// TYPES ///////////////////////////////////////////////////////////////////
// DEFINES /////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/**
 ** \brief Main implementation of the procedure executor
 **
 ** \par Description and usage:
 **
 **		Main implementation of the SPELLexecutorIF interface for the SPELL
 **		Executor process.
 **
**////////////////////////////////////////////////////////////////////////////
class SPELLexecutorImpl: public SPELLexecutorIF
{
public: //--------------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Constructor
		**////////////////////////////////////////////////////////////////////
		SPELLexecutorImpl();

		//////////////////////////////////////////////////////////////////////
		/** Destructor.
		**////////////////////////////////////////////////////////////////////
		virtual ~SPELLexecutorImpl();

    // STATIC ////////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////

    // *******************************************************************
    // INITIALIZATION
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void initialize( SPELLcif* cif,
						 SPELLcontrollerIF* controller,
						 SPELLschedulerIF* scheduler,
						 SPELLcallstackIF* callstack,
						 SPELLframeManager* frameManager );

	    //////////////////////////////////////////////////////////////////////
	    /** \see SPELLexecutorIF.
	    **////////////////////////////////////////////////////////////////////
	    void prepare( const std::string& procId, const SPELLcontextConfig& ctxConfig );

	// *******************************************************************
	// COMPONENT ACCESSORS
	// *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLcif& getCIF() const { return *m_cif; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLcallstackIF& getCallstack() const { return *m_callstack; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLcontrollerIF& getController() const { return *m_controller; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLschedulerIF& getScheduler() const { return *m_scheduler; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLchildManager& getChildManager() const { return *m_childMgr; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLexecutorConfig& getConfiguration() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLvariableManager& getVariableManager() const { return *m_varManager; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLframeManager& getFrameManager() const { return *m_frameManager; };

    // *******************************************************************
    // EXECUTION ENTRY POINTS
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void execute();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void recover();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void finalize();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void save();

    // *******************************************************************
    // MAIN EXECUTION CONTROL
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void addDispatchListener( SPELLdispatchListener* listener );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void removeDispatchListener( SPELLdispatchListener* listener );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		int dispatch( PyObject* obj, PyFrameObject* frame, int what, PyObject* args );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void command( const ExecutorCommand& cmd, const bool high_priority );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void abort( const std::string& message, bool systemAborted );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void finish( const std::string& message );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void pause();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void interrupt();

    // *******************************************************************
    // STATUS INFORMATION
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const SPELLexecutorStatus getStatus() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const std::string getContextName() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const std::string getInstanceId() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setControllingClient( const std::string& clientId );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setControllingHost( const std::string& hostName );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const std::string getControllingHost() const;

    // *******************************************************************
    // EXECUTION CONFIGURATION PARAMETERS
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setProcedurePath( const std::string& procPath ) { m_procPath = procPath; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setLibraryPath( const std::string& libPath ) { m_libPath = libPath; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setRunInto( const bool enabled );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setByStep( const bool enabled );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setBrowsableLib( const SPELLbrowsableLibMode& browsableLib );

		void setBrowsableLibStr( const std::string& browsableLibStr );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setExecDelay( const int delay );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setPromptWarningDelay( const int delay );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setForceTcConfirm( const bool force );

    // *******************************************************************
    // LANGUAGE INTERLOCK
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void processLock();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void processUnlock();

    // *******************************************************************
    // EXECUTION MANIPULATION
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const bool canSkip();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const bool goNextLine();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const bool goLabel( const std::string& label, bool programmed );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const bool goLine( const int line );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const bool setBreakpoint( const std::string& file,
				                  const unsigned int line,
				                  const SPELLbreakpointType type );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void clearBreakpoints();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const bool runScript( const std::string& script );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void executeUserAction();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setUserAction( const SPELLuserAction& action );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void enableUserAction( const bool enable );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void dismissUserAction();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const SPELLuserAction getUserAction() const { return m_userAction; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void stageReached( const std::string& id, const std::string& title );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void displayStage( const std::string& id, const std::string& title );

    // DATA MEMBERS //////////////////////////////////////////////////////////

protected: //-----------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
		/** Identifies the status after an error recovery */
		typedef enum AfterError_
		{
			CANNOT_RECOVER,	// Will not recover because there is no ws support
			CANCEL_RECOVER, // Will not recover because the user does not want
			RECOVER_SUCCESS,// Recovery ok
			RECOVER_FAILED  // Recovery failed
		}
		AfterError;
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Listener notifications
		**////////////////////////////////////////////////////////////////////
		void notifyLineEvent( PyFrameObject* frame, const std::string& file, const int line, const std::string& name );
		void notifyCallEvent( PyFrameObject* frame, const std::string& file, const int line, const std::string& name );
		void notifyReturnEvent( PyFrameObject* frame, const std::string& file, const int line, const std::string& name );
		void notifyErrorEvent( PyFrameObject* frame, const std::string& file, const int line, const std::string& name );

		//////////////////////////////////////////////////////////////////////
		/** Process a dispatched exception
		 *
		 * \return True if the dispatch processing shall not continue
		**////////////////////////////////////////////////////////////////////
		bool processException( PyObject* data, int lineno );

		//////////////////////////////////////////////////////////////////////
		/** Internal implementation of the execute() method
		**////////////////////////////////////////////////////////////////////
		void executeInternal( bool reset );

		//////////////////////////////////////////////////////////////////////
		/** By-Step implementation. If the feature is enabled and the current
		 * procedure line is a Step, pause the execution.
		 *
		 * \param frameLine IN: the current line in the procedure.
		**////////////////////////////////////////////////////////////////////
		const bool checkByStep( const int& frameLine );

		//////////////////////////////////////////////////////////////////////
		/** INIT step feature checker
		 *
		 * \param frameLine IN: the current line in the procedure.
		 *
		 * \returns True if the dispatching shall be aborted and control
		 *  returned to Python side immediately.
		**////////////////////////////////////////////////////////////////////
		const bool checkInitStep( const int& frameLine );

		//////////////////////////////////////////////////////////////////////
		/** Breakpoint checker. If a breakpoint is set, pause the execution.
		 *
		 * \param file IN: current file name.
		 * \param lineNo IN: the current line in the procedure.
		 *
		**////////////////////////////////////////////////////////////////////
		void checkBreakpoint( const std::string& file, unsigned int lineNo );

		//////////////////////////////////////////////////////////////////////
		/** Error recovery implementation
		 *
		 * \returns True if the error can be recovered
		**////////////////////////////////////////////////////////////////////
		const AfterError handleExecutionError();

		//////////////////////////////////////////////////////////////////////
		/** Load execution environment data and instances
		**////////////////////////////////////////////////////////////////////
		void loadExecutionEnvironment();

		//////////////////////////////////////////////////////////////////////
		/** Load SPELL driver
		**////////////////////////////////////////////////////////////////////
		void loadDriver();

		//////////////////////////////////////////////////////////////////////
		/** Unload SPELL driver.
		 *
		 * \param shutdown IN: If true, unload completely all data. If false,
		 *  just cleanup the driver, but do not remove it completely (this
		 *  is handled on driver side, not in executor)
		**////////////////////////////////////////////////////////////////////
		void unloadDriver( bool shutdown );

		//////////////////////////////////////////////////////////////////////
		/** Called when the execution finishes with errors. The behavior
		 * depends on the recovery mechanism status and user's choice.
		 *
		 * \return True if the execution shall be started over.
		**////////////////////////////////////////////////////////////////////
		bool executorFinishedWithErrors();

		//////////////////////////////////////////////////////////////////////
		/** Called when the execution finishes sucessfully. The behavior
		 * depends on the user's choice.
		 *
		 * \return True if the execution shall be started over.
		**////////////////////////////////////////////////////////////////////
		bool executorFinishedRight();

		//////////////////////////////////////////////////////////////////////
		/** Called when the execution is aborted. The behavior
		 * depends on the user's choice.
		 *
		 * \return True if the execution shall be started over.
		**////////////////////////////////////////////////////////////////////
		bool executorAborted();

		//////////////////////////////////////////////////////////////////////
		/** Waits for the user's choice: close the procedure or reload it.
		 *
		 * \return True if the execution shall be started over.
		**////////////////////////////////////////////////////////////////////
		bool reloadOrClose();

    // DATA MEMBERS //////////////////////////////////////////////////////////

private: //-------------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Install the calling arguments data container on the main scope.
		**////////////////////////////////////////////////////////////////////
		void installCallingArguments();

		//////////////////////////////////////////////////////////////////////
		/** Install the internal variables data container on the main scope.
		**////////////////////////////////////////////////////////////////////
		void installInternalVariables();

		//////////////////////////////////////////////////////////////////////
		/** Change the force TC flag on the adapter layer
		**////////////////////////////////////////////////////////////////////
		void setForceTcConfirmInternal( bool force );

    // DATA MEMBERS //////////////////////////////////////////////////////////

		/** True if the initial configuration parameters have been set */
		bool                         m_initialized;
		/** Holds the procedure instance identifier */
		std::string                  m_instanceId;
		/** Holds the parent procedure, if any */

		std::string                  m_parentId;
		/** Holds the child procedure, if any */
		std::string                  m_childId;

		/** Used for dispatching filter (procedures) */
		std::string                  m_procPath;
		/** Used for dispatching filter (user library) */
		std::string                  m_libPath;
		/** Output directory location */
		std::string                  m_outputDir;
		/** Input directory location */
		std::string                  m_inputDir;

		/** True when the INIT step, if any, has been reached */
		bool                         m_initStepDone;
		/** Holds the lines in the main procedure that are executed during INIT mode */
		std::list<unsigned int>      m_initLines;

		/** Holds the user action data if any */
		SPELLuserAction				 m_userAction;

		/** Holds the command controller */
		SPELLcontrollerIF*           m_controller;
		/** Holds the scheduler controller */
		SPELLschedulerIF*            m_scheduler;
		/** Holds the callstack model */
		SPELLcallstackIF*            m_callstack;
		/** Holds the reference to client interface */
		SPELLcif*                    m_cif;
		/** Holds the child procedure manager */
		SPELLchildManager*           m_childMgr;
		/** Holds the execution control frame */
		SPELLframeManager*           m_frameManager;
		/** Holds the module import checker */
		SPELLimportChecker           m_importChecker;
		/** Holds the variable manager */
		SPELLvariableManager*        m_varManager;

		/** Command synchronization lock */
		SPELLmutex                   m_cmdLock;
		/** Dispatch synchronization lock */
		SPELLmutex                   m_dspLock;

		/** Next programmed goto target */
		std::string                  m_gotoTarget;

		/** Dispatch event listeners */
		SPELLdispatchListeners       m_listeners;
};

/*@}*/
#endif
