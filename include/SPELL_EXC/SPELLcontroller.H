// ################################################################################
// FILE       : SPELLcontroller.H
// DATE       : Mar 17, 2011
// PROJECT    : SPELL
// DESCRIPTION: Controls the command processing in a separate thread.
// --------------------------------------------------------------------------------
//
//  Copyright (C) 2008, 2015 SES ENGINEERING, Luxembourg S.A.R.L.
//
//  This file is part of SPELL.
//
// SPELL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// SPELL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with SPELL. If not, see <http://www.gnu.org/licenses/>.
//
// ################################################################################

#ifndef __SPELL_CONTROLLER_H__
#define __SPELL_CONTROLLER_H__

// FILES TO INCLUDE ////////////////////////////////////////////////////////
// System includes ---------------------------------------------------------
// Local includes ----------------------------------------------------------
#include "SPELL_EXC/SPELLcontrollerIF.H"
#include "SPELL_EXC/SPELLcommandMailbox.H"
// Project includes --------------------------------------------------------
#include "SPELL_SYN/SPELLthread.H"
#include "SPELL_SYN/SPELLevent.H"


/** \addtogroup SPELL_EXC */
/*@{*/


// FORWARD REFERENCES //////////////////////////////////////////////////////
// TYPES ///////////////////////////////////////////////////////////////////
// DEFINES /////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/**
 ** \brief Command controller thread
 **
 ** \par Description and usage:
 **
 **		Processes the commands received from the client and keeps the
 **		procedure status.
 **
 **	\see SPELLcontrollerIF.
 **
**////////////////////////////////////////////////////////////////////////////
class SPELLcontroller: public SPELLthread, public SPELLcontrollerIF
{
public: //--------------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Constructor.
		**////////////////////////////////////////////////////////////////////
		SPELLcontroller( const std::string& procId );

		//////////////////////////////////////////////////////////////////////
		/** Destructor.
		**////////////////////////////////////////////////////////////////////
		~SPELLcontroller();

    // STATIC ////////////////////////////////////////////////////////////////

    // METHODS ///////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Thread main function. Will be in charge of process all incoming
		 * commands for the executor, queue them appropriately and act
		 * accordingly.
		**////////////////////////////////////////////////////////////////////
		void run();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void begin() { start(); };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void stop();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void reset();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void command( const ExecutorCommand& cmd, const bool queueIt, const bool high_priority );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const bool shouldReload() const { return m_reload; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const bool shouldRecover();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const SPELLexecutorStatus getStatus() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const SPELLexecutionMode getMode() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setStatus( const SPELLexecutorStatus& st );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setMode( const SPELLexecutionMode& mode );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setCondition( const std::string& condition );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const std::string& getCondition() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const bool hasCondition() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setAutoRun();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void enableRunInto( const bool enable );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const bool checkAborted();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void executionLock();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void executionUnlock();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLdispatchListener.
		**////////////////////////////////////////////////////////////////////
		std::string getId() { return "(controller)"; };

		//////////////////////////////////////////////////////////////////////
		/** Line event dispatch processor. Here is the point where:
		 *
		 * 1. The stepping feature is implemented
		 * 2. Execution delay is applied, if any
		 * 3. Procedure initial scheduling condition is processed
		 * 4. Skip-out-of-function mechanism (by means of the return value)
		 *
		 * \param file IN: file being currently processes
		 * \param line IN: current line in the file
		 * \param name IN: name of the Python module
		 *
		**////////////////////////////////////////////////////////////////////
		void callbackEventLine( PyFrameObject* frame, const std::string& file, const int line, const std::string& name );

		//////////////////////////////////////////////////////////////////////
		/** Call event dispatch processor. Here is the point where:
		 *
		 * 1. Loaded status is triggered
		 * 2. Procedure is paused after correct load
		 * 3. Step over mechanism for functions is enabled
		 *
		 * \param file IN: file being currently processes
		 * \param line IN: current line in the file
		 * \param name IN: name of the Python module
		 *
		**////////////////////////////////////////////////////////////////////
		void callbackEventCall( PyFrameObject* frame, const std::string& file, const int line, const std::string& name);

		//////////////////////////////////////////////////////////////////////
		/** Return event dispatch processor. Here is the point where:
		 *
		 * 1. Step over is disabled.
		 *
		 * \param file IN: file being currently processes
		 * \param line IN: current line in the file
		 * \param name IN: name of the Python module
		 *
		**////////////////////////////////////////////////////////////////////
		void callbackEventReturn( PyFrameObject* frame, const std::string& file, const int line, const std::string& name);

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLdispatchListener.
		**////////////////////////////////////////////////////////////////////
		void callbackEventError( PyFrameObject* frame, const std::string& file, const int line, const std::string& name ) {;};

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		bool shallRepeat() { return m_shallRepeat; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setStartTime();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setEndTime();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setFinished();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setError( const std::string& error, const std::string& reason, const bool fatal );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void waitCommand();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void addControllerListener( SPELLcontrollerListener* listener );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void removeControllerListener( SPELLcontrollerListener* listener );

    // DATA MEMBERS //////////////////////////////////////////////////////////

protected: //-----------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Notification to listeners
		**////////////////////////////////////////////////////////////////////
		void notifyBeforeWait();
		void notifyAfterWait();
		void notifyBeforeStatusChange( const SPELLexecutorStatus& status );
		void notifyAfterStatusChange( const SPELLexecutorStatus& status );
		void notifyOnStart();
		void notifyOnFinish();
		void notifyOnLineStep();
		void notifyBeforeDriverOperation();
		void notifyAfterDriverOperation();
		void notifyCommandToCore( const std::string& commandId );

		//////////////////////////////////////////////////////////////////////
		/** Perform the STEP or STEP_OVER command operations.
		 *
		 * \param stepOver IN: if true, execute STEP_OVER.
		**////////////////////////////////////////////////////////////////////
		void doStep( const bool stepOver );

		//////////////////////////////////////////////////////////////////////
		/** Perform the RUN command operations.
		**////////////////////////////////////////////////////////////////////
		void doPlay();

		//////////////////////////////////////////////////////////////////////
		/** Perform the PAUSE command operations.
		**////////////////////////////////////////////////////////////////////
		void doPause();

		//////////////////////////////////////////////////////////////////////
		/** Perform the INTERRUPT command operations.
		**////////////////////////////////////////////////////////////////////
		void doInterrupt();

		//////////////////////////////////////////////////////////////////////
		/** Perform the ABORT command operations.
		**////////////////////////////////////////////////////////////////////
		void doAbort();

		//////////////////////////////////////////////////////////////////////
		/** Perform the finish command operations.
		**////////////////////////////////////////////////////////////////////
		void doFinish();

		//////////////////////////////////////////////////////////////////////
		/** Prepare to close the procedure (actual closure is done by the
		 * interpreter object)
		**////////////////////////////////////////////////////////////////////
		void doClose();

		//////////////////////////////////////////////////////////////////////
		/** Prepare to reload the procedure (actual reload is done by the
		 * interpreter object)
		**////////////////////////////////////////////////////////////////////
		void doReload();

		//////////////////////////////////////////////////////////////////////
		/** Prepare to recover the procedure (actual recovery is done by the
		 * interpreter object)
		**////////////////////////////////////////////////////////////////////
		void doRecover();

		//////////////////////////////////////////////////////////////////////
		/** Perform the SKIP command operations.
		**////////////////////////////////////////////////////////////////////
		void doSkip();

		//////////////////////////////////////////////////////////////////////
		/** Perform the GOTO(label) command operations.
		**////////////////////////////////////////////////////////////////////
		void doGoto( const std::string& label );

		//////////////////////////////////////////////////////////////////////
		/** Perform the GOTO(line) command operations.
		**////////////////////////////////////////////////////////////////////
		void doGoto( const int line );

		//////////////////////////////////////////////////////////////////////
		/** Perform the SCRIPT command operations.
		**////////////////////////////////////////////////////////////////////
		void doScript( const std::string& script, const bool override );

		//////////////////////////////////////////////////////////////////////
		/** Perform the ACTION command operation
		**////////////////////////////////////////////////////////////////////
		void doUserAction();

		//////////////////////////////////////////////////////////////////////
		/** Block the dispatcher (stepping/pause mechanism)
		**////////////////////////////////////////////////////////////////////
		void doWait();

		//////////////////////////////////////////////////////////////////////
		/** Unblock the dispatcher (stepping/pause mechanism)
		**////////////////////////////////////////////////////////////////////
		void doContinue();

		//////////////////////////////////////////////////////////////////////
		/** Process a command
		**////////////////////////////////////////////////////////////////////
		void executeCommand( const ExecutorCommand& cmd );

		//////////////////////////////////////////////////////////////////////
		/** True if command pending
		**////////////////////////////////////////////////////////////////////
		bool isCommandPending() { return m_commandPending.isClear(); };

		//////////////////////////////////////////////////////////////////////
		/** True if command pending
		**////////////////////////////////////////////////////////////////////
		void setCommandFinished() { m_commandPending.set(); };

		//////////////////////////////////////////////////////////////////////
		/** Wait command to finish
		**////////////////////////////////////////////////////////////////////
		void waitCommandFinished() { m_commandPending.wait(); };

		//////////////////////////////////////////////////////////////////////
		/** Start command processing
		**////////////////////////////////////////////////////////////////////
		void startCommandProcessing() { m_commandPending.clear(); };

		//////////////////////////////////////////////////////////////////////
		/** Notify event
		**////////////////////////////////////////////////////////////////////
		void raiseEvent( const std::string& message );

    // DATA MEMBERS //////////////////////////////////////////////////////////

private: //-------------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////
    // DATA MEMBERS //////////////////////////////////////////////////////////
		/** Holds the dispatching if a command waits to be executed */
		SPELLevent           m_commandPending;
		/** Event used for the stepping/pause mechanism (dispatcher blockage) */
		SPELLevent           m_execLock;
		/** Event used for the language lock (command processing) */
		SPELLevent           m_controllerLock;
		/** Event used for blocking the interpreter object until the recovery
		feasibility is determined and the executor is in the proper state. */
		SPELLevent           m_recoverEvent;
		/** Holds the current execution status. */
		SPELLexecutorStatus   m_status;
		/** Holds the current execution mode. */
		SPELLexecutionMode    m_mode;
		/** Reference to the mailbox object. */
		SPELLcommandMailbox   m_mailbox;
		/** True if the skip-out-function mechanism is being used. */
		bool m_skipping;
		/** True if the procedure has been aborted. */
		bool m_abort;
		/** True if the procedure is finished. */
		bool m_finished;
		/** True if the procedure is in error state. */
		bool m_error;
		/** True if the procedure shall go to play mode right away after load. */
		bool m_autorun;
		/** True if the procedure can recover state. */
		bool m_recover;
		/** True if the user requires the procedure to be reloaded. */
		bool m_reload;
		/** True if the user wants to pause. Required for pausing during step overs */
		bool m_wantPause;
		/** True if the user wants to interrupt. Required to differentiate interruptions from pauses */
		bool m_wantInterrupt;
		/** Dispatch loop repeat flag */
		bool m_shallRepeat;
		/** Holds the name of the main procedure file. */
		std::string m_mainProc;
		/** Holds the name of the current procedure file. */
		std::string m_currentProc;
		/** Holds the scheduling condition, if any */
		std::string m_condition;
		/** Holds the controller listeners */
		SPELLcontrollerListeners m_listeners;
		/** Holds the procedure id */
		std::string m_procId;
};

/*@}*/
#endif
