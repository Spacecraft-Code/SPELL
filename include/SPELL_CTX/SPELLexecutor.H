// ################################################################################
// FILE       : SPELLexecutor.H
// DATE       : Apr 11, 2011
// PROJECT    : SPELL
// DESCRIPTION: Executor manager and controller
// --------------------------------------------------------------------------------
//
//  Copyright (C) 2008, 2015 SES ENGINEERING, Luxembourg S.A.R.L.
//
//  This file is part of SPELL.
//
// SPELL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// SPELL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with SPELL. If not, see <http://www.gnu.org/licenses/>.
//
// ################################################################################

#ifndef __SPELL_EXECUTOR_H__
#define __SPELL_EXECUTOR_H__

// FILES TO INCLUDE //////////////////////////////////////////////////////////
// Local includes ------------------------------------------------------------
#include "SPELL_CTX/SPELLexecutorIPC.H"
#include "SPELL_CTX/SPELLexecutorModel.H"
#include "SPELL_CTX/SPELLexecutorListener.H"
#include "SPELL_CTX/SPELLexecutorStartupParams.H"
#include "SPELL_CTX/SPELLclient.H"
// Project includes ----------------------------------------------------------
#include "SPELL_PRC/SPELLprocessManager.H"
#include "SPELL_EXC/SPELLcommand.H"
#include "SPELL_EXC/SPELLexecutorStatus.H"
#include "SPELL_SYN/SPELLevent.H"
#include "SPELL_SYN/SPELLmutex.H"

/** \addtogroup SPELL_CTX */
/*@{*/


// FORWARD REFERENCES ////////////////////////////////////////////////////////
class LoginMonitor;
// TYPES /////////////////////////////////////////////////////////////////////
// DEFINES ///////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/**
 ** \brief
 **
**////////////////////////////////////////////////////////////////////////////
class SPELLexecutor : public SPELLexecutorListener, SPELLprocessListener
{
public: //--------------------------------------------------------------------

	// EXCEPTIONS ////////////////////////////////////////////////////////////
	// ENUMS /////////////////////////////////////////////////////////////////
	// TYPES /////////////////////////////////////////////////////////////////
	// LIFECYCLE /////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Constructor.
		**////////////////////////////////////////////////////////////////////
		SPELLexecutor( const SPELLexecutorStartupParams& config, SPELLclient* controllingClient );

		//////////////////////////////////////////////////////////////////////
		/** Destructor.
		**////////////////////////////////////////////////////////////////////
		virtual ~SPELLexecutor();

	// METHODS ///////////////////////////////////////////////////////////////

	    //////////////////////////////////////////////////////////////////////
	    /** Start the executor process
	    **////////////////////////////////////////////////////////////////////
	    void start();

	    //////////////////////////////////////////////////////////////////////
	    /** Close the executor process
	    **////////////////////////////////////////////////////////////////////
	    void close();

	    //////////////////////////////////////////////////////////////////////
	    /** Kill the executor process
	    **////////////////////////////////////////////////////////////////////
	    void kill();

	    //////////////////////////////////////////////////////////////////////
	    /** Wait for a given executor status
	     *
	     * \returns True on timeout
	    **////////////////////////////////////////////////////////////////////
	    bool waitStatus( const SPELLexecutorStatus& status, unsigned int timeoutSec );

	    //////////////////////////////////////////////////////////////////////
	    /** Wait for executor login
	     *
	     * \returns True if logged in
	    **////////////////////////////////////////////////////////////////////
	    bool waitLogin( unsigned int timeoutMsec );

	    //////////////////////////////////////////////////////////////////////
	    /** Check for executor login
	     *
	     * \returns True if logged in
	    **////////////////////////////////////////////////////////////////////
	    bool isLoggedIn() { return m_loggedIn; };

	    //////////////////////////////////////////////////////////////////////
	    /** Get the status of the executor
	     *
	     * \returns The status
	    **////////////////////////////////////////////////////////////////////
	    SPELLexecutorStatus getStatus();

	    //////////////////////////////////////////////////////////////////////
	    /** Check if the executor is active
	     *
	     * \returns True if active
	    **////////////////////////////////////////////////////////////////////
	    bool isActive();

	    //////////////////////////////////////////////////////////////////////
	    /** Check if the executor has a parent procedure
	     *
	     * \returns True if has a parent
	    **////////////////////////////////////////////////////////////////////
	    bool hasParent() { return m_model.getParentInstanceId() != ""; } ;

	    //////////////////////////////////////////////////////////////////////
	    /** Get the executor parent procedure
	     *
	     * \returns The parent procedure id
	    **////////////////////////////////////////////////////////////////////
	    std::string getParentInstanceId() { return m_model.getParentInstanceId(); } ;

	    //////////////////////////////////////////////////////////////////////
	    /** Send a command to the executor
	    **////////////////////////////////////////////////////////////////////
	    void command( const ExecutorCommand& command );

	    //////////////////////////////////////////////////////////////////////
	    /** Set the controlling client
	    **////////////////////////////////////////////////////////////////////
	    void setControllingClient( SPELLclient* client );

	    //////////////////////////////////////////////////////////////////////
	    /** Set the procedure to headless (background) mode
	    **////////////////////////////////////////////////////////////////////
	    void setBackground();

	    //////////////////////////////////////////////////////////////////////
	    /** Check whether the procedure is in headless (background) mode
	    **////////////////////////////////////////////////////////////////////
	    bool isBackground() { return m_clientConnection == CLI_BACKGROUND; };

	    //////////////////////////////////////////////////////////////////////
	    /** Remove the controlling client
	    **////////////////////////////////////////////////////////////////////
	    void removeControllingClient( bool clientLost );

	    //////////////////////////////////////////////////////////////////////
	    /** Check if it has controlling client
	    **////////////////////////////////////////////////////////////////////
	    bool hasControllingClient();

	    //////////////////////////////////////////////////////////////////////
	    /** Check if it has controlling client
	    **////////////////////////////////////////////////////////////////////
	    SPELLclient* getControllingClient();

	    //////////////////////////////////////////////////////////////////////
	    /** Send a message to the executor process
	    **////////////////////////////////////////////////////////////////////
	    void sendMessageToExecutor( const SPELLipcMessage& msg );

	    //////////////////////////////////////////////////////////////////////
	    /** Send a request to the executor process
	    **////////////////////////////////////////////////////////////////////
	    SPELLipcMessage sendRequestToExecutor( const SPELLipcMessage& msg );

	    //////////////////////////////////////////////////////////////////////
	    /** Get the executor model
	    **////////////////////////////////////////////////////////////////////
	    SPELLexecutorModel& getModel() { return m_model; };

	    //////////////////////////////////////////////////////////////////////
	    /** Register executor notifier for monitoring mode
	    **////////////////////////////////////////////////////////////////////
	    void registerNotifier( std::string id, SPELLexecutorListener* listener );

	    //////////////////////////////////////////////////////////////////////
	    /** Deregister executor notifier
	    **////////////////////////////////////////////////////////////////////
	    void deregisterNotifier( std::string id );

	// DATA MEMBERS //////////////////////////////////////////////////////////

protected: //-----------------------------------------------------------------

		friend class SPELLexecutorInterestList;
		friend class SPELLprocessManager;
		friend class SPELLexecutorIPC;

	// EXCEPTIONS ////////////////////////////////////////////////////////////
	// ENUMS /////////////////////////////////////////////////////////////////
	// TYPES /////////////////////////////////////////////////////////////////
	// STATIC ////////////////////////////////////////////////////////////////
	// LIFECYCLE /////////////////////////////////////////////////////////////
	// METHODS ///////////////////////////////////////////////////////////////

		//====================================================================
		// EXECUTOR REQUEST HANDLING
		//====================================================================

		SPELLipcMessage executorLogin( const SPELLipcMessage& msg );

		void executorNotification( const SPELLipcMessage& msg );

		//====================================================================
		// INTERNAL IPC METHODS
		//====================================================================

	    //////////////////////////////////////////////////////////////////////
	    /** \see SPELLexecutorListener.
	    **////////////////////////////////////////////////////////////////////
	    void processMessageFromExecutor( SPELLipcMessage msg );

	    //////////////////////////////////////////////////////////////////////
	    /** \see SPELLexecutorListener.
	    **////////////////////////////////////////////////////////////////////
	    SPELLipcMessage processRequestFromExecutor( SPELLipcMessage msg );

	    //////////////////////////////////////////////////////////////////////
	    /** Forward a message from the executor to the client
	    **////////////////////////////////////////////////////////////////////
	    void forwardMessageToClient( const SPELLipcMessage& msg );

	    //////////////////////////////////////////////////////////////////////
	    /** Forward a request from the executor to the client
	    **////////////////////////////////////////////////////////////////////
	    SPELLipcMessage forwardRequestToClient( const SPELLipcMessage& msg );

	    //////////////////////////////////////////////////////////////////////
	    /** Force an executor pause
	    **////////////////////////////////////////////////////////////////////
	    void forcePause();

		//====================================================================
		// INTERNAL PROCESS CONTROL METHODS
		//====================================================================

	    //////////////////////////////////////////////////////////////////////
	    /** Check if the executor is active
	     *
	     * \returns True if active
	    **////////////////////////////////////////////////////////////////////
	    bool processOk();

	    //////////////////////////////////////////////////////////////////////
	    /** Wait until the executor process has finished
	    **////////////////////////////////////////////////////////////////////
	    void waitFinish();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLprocessListener.
		**////////////////////////////////////////////////////////////////////
		void processStarted( const std::string& identifier );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLprocessListener.
		**////////////////////////////////////////////////////////////////////
		void processFinished( const std::string& identifier, const int& retValue );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLprocessListener.
		**////////////////////////////////////////////////////////////////////
		void processKilled( const std::string& identifier );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLprocessListener.
		**////////////////////////////////////////////////////////////////////
		void processFailed( const std::string& identifier );


private: //-------------------------------------------------------------------

	// EXCEPTIONS ////////////////////////////////////////////////////////////
	// ENUMS /////////////////////////////////////////////////////////////////
	// TYPES /////////////////////////////////////////////////////////////////

		typedef enum ClientConnection_
		{
			CLI_CONNECTED,
			CLI_NO_CLIENT,
			CLI_ERROR,
			CLI_BACKGROUND

		} ClientConnection;

	// STATIC ////////////////////////////////////////////////////////////////
	// LIFECYCLE /////////////////////////////////////////////////////////////
	// METHODS ///////////////////////////////////////////////////////////////

		void executorStatusChanged( const SPELLexecutorStatus& status, const std::string& error = "", const std::string& reason = "" );

	// DATA MEMBERS //////////////////////////////////////////////////////////

		/** True if the model is for a reconnecting executor */
		bool m_reconnecting;
		/** True if the executor logged in */
		bool m_loggedIn;
		/** Counts number of notifications not acknlowledged */
		unsigned int m_notAckNotifications;
		/** Holds the procedure information */
		SPELLexecutorModel m_model;
		/** Holds the IPC executor proxy */
		SPELLexecutorIPC m_ipc;
		/** Holds the controlling client */
		SPELLclient* m_controllingClient;
		/** Mode of the controlling client if any  */
		ClientConnection m_clientConnection;
		/** Holds the process status */
		SPELLprocessStatus m_processStatus;
		/** Holds the executor status */
		SPELLexecutorStatus m_status;
		/** Event for process start */
		SPELLevent m_processStartedEvent;
		/** Event for process stop (finish/crash) */
		SPELLevent m_processStoppedEvent;
		/** Event for executor login */
		SPELLevent m_executorLoggedInEvent;
		/** Event for executor log out */
		SPELLevent m_executorLoggedOutEvent;
		/** Synchronizes client communications and client operations */
		SPELLmutex m_clientLock;
		/** Event for waiting executor status */
		SPELLevent m_executorStatusEvent;
		/** Login monitor */
		LoginMonitor* m_loginMonitor;

};


/*@}*/
#endif
